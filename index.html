<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - adaptive tone-mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}
			h1 { }
			a { color:skyblue; text-decoration:none }
			canvas { pointer-events:none; z-index:0; position:relative; }
			.label { background-color: black; position: absolute; z-index: 100; padding: 5px }
		</style>
	</head>

	<body>


		<script src="js/three.min.js"></script>
		<script src="js/SkyShader.js"></script>
		<script src="js/CanvasRenderer.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<script src="js/CopyShader.js"></script>
		<script src="js/LuminosityShader.js"></script>
		<script src="js/ConvolutionShader.js"></script>
		<script src="js/ToneMapShader.js"></script>
		<script src="js/GammaCorrectionShader.js"></script>

		<script src="js/EffectComposer.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/MaskPass.js"></script>
		<script src="js/ShaderPass.js"></script>
		<script src="js/BloomPass.js"></script>
		<script src="js/AdaptiveToneMappingPass.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/FlyControls.js"></script>
		<script src="js/stats.min.js"></script>
		
		<script src="js/Projector.js"></script>
		<script src="js/LensFlares.js"></script>

		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var width = window.innerWidth,
				height = window.innerHeight,
				radius   = 300,
				segments = 32,
				rotation = 6,
				stats;

			init();
				
			function init() {
				
				// СОЗДАЕМ КОНТЕЙНЕР
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				// СОЗДАЕМ СЦЕНУ И КАМЕРУ
				var scene = new THREE.Scene();
				var camera = new THREE.PerspectiveCamera(45, width / height, 0.01, 101000);
				camera.position.z = 6300;
				
				// СОЗДАЕМ РЕНДЕРНЫЙ ДВИЖОК И ДОБАВЛЯЕМ ЕГО В КОНТЕЙНЕР
				render3D = new THREE.WebGLRenderer({antialias: true, alpha: true });
				render3D.setSize(width, height);
				render3D.domElement.style.position = "relative";
				render3D.setClearColor( 0x000000 );
				container.appendChild(render3D.domElement);
				
				// СОЗДАЕМ ИСТОЧНИК ОСВЕЩЕНИЯ
				var light = new THREE.DirectionalLight(0xffffff, 4);
				light.position.set(0,0,-5000);
				light.color.setHSL( 0.618, 0.45, 1.0 );	
				//light.shadowCameraVisible = true;
				scene.add(light);
				
				// Создаем землю -----------------------------------------------------------------------
				// Объявляем 3д объект - Земля
				var containerEarth = new THREE.Object3D();
				containerEarth.rotateZ(-23.4 * Math.PI/180);
				containerEarth.position.z = 0;
				scene.add(containerEarth);
				
				// ШЕЙДЕР
				var atmoShader = {
					side: THREE.BackSide,
					// blending: THREE.AdditiveBlending,
					transparent: true,
					lights: true,
					uniforms: THREE.UniformsUtils.merge( [
						THREE.UniformsLib[ "common" ],
						THREE.UniformsLib[ "lights" ]
					] ),
					vertexShader: [
						"varying vec3 vViewPosition;",
						"varying vec3 vNormal;",
						"void main() {",
							THREE.ShaderChunk[ "beginnormal_vertex" ],
							THREE.ShaderChunk[ "defaultnormal_vertex" ],
							"	vNormal = normalize( transformedNormal );",
							"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
							"vViewPosition = -mvPosition.xyz;",
							"gl_Position = projectionMatrix * mvPosition;",
						"}"
					].join("\n"),
					fragmentShader: [
						THREE.ShaderChunk[ "common" ],
						THREE.ShaderChunk[ "bsdfs" ],
						THREE.ShaderChunk[ "lights_pars" ],
						THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
						"void main() {",
							"vec3 normal = normalize( -vNormal );",
							"vec3 viewPosition = normalize( vViewPosition );",
							"#if NUM_DIR_LIGHTS > 0",
								"vec3 dirDiffuse = vec3( 0.0 );",
								"for( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
									"vec4 lDirection = viewMatrix * vec4( directionalLights[i].direction, 0.0 );",
									"vec3 dirVector = normalize( lDirection.xyz );",
									"float dotProduct = dot( viewPosition, dirVector );",
									"dotProduct = 1.0 * max( dotProduct, 0.0 ) + (1.0 - max( -dot( normal, dirVector ), 0.0 ));",
									"dotProduct *= dotProduct;",
									"dirDiffuse += max( 0.5 * dotProduct, 0.0 ) * directionalLights[i].color;",
								"}",
							"#endif",
							//Fade out atmosphere at edge
							"float viewDot = abs(dot( normal, viewPosition ));",
							"viewDot = clamp( pow( viewDot + 0.6, 10.0 ), 0.0, 1.0);",
							"vec3 colour = vec3( 0.05, 0.09, 0.13 ) * dirDiffuse;",
							"gl_FragColor = vec4( colour, viewDot );",
						"}"
					].join("\n"),
				};

				
				var atmoPosition = 0;
				
				// ОБЪЕКТ - АТМОСФЕРА
				var geometry = new THREE.SphereGeometry(radius, 32, 32, 1, 3, atmoPosition, 3);
				var material = new THREE.ShaderMaterial( atmoShader );
				var mesh = new THREE.Mesh(geometry, material );
				mesh.scale.multiplyScalar(1.01);
				containerEarth.add( mesh );
				
				var geometry = new THREE.SphereGeometry(radius, 32, 32, 1, 3, atmoPosition, 3);
				var material = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					shininess: 200
				} );				
				var mesh = new THREE.Mesh(geometry, material );
				mesh.scale.multiplyScalar(1.01);
				containerEarth.add( mesh );
												
				var geometry = new THREE.SphereGeometry(radius, 32, 32, 1, 3, atmoPosition, 3);
				var material = new THREE.MeshBasicMaterial( {
					color: 0xffffff,
					blending: THREE.AdditiveBlending,
					transparent: true,
					depthTest: false
				} );	
				var mesh = new THREE.Mesh(geometry, material );
				mesh.scale.multiplyScalar(1.01);
				containerEarth.add( mesh );
				
				var textureLoader = new THREE.TextureLoader();
				var sphere = createSphere(radius, segments);
				function createSphere(radius, segments) {
					return new THREE.Mesh(
						new THREE.SphereGeometry(radius, segments, segments),
						new THREE.MeshPhongMaterial({
							map:         textureLoader.load("js/earth.jpg" ),
							bumpMap:     textureLoader.load("js/bump.jpg" ),
							bumpScale:   0.001,
							specularMap: textureLoader.load("js/specular.jpg" ),
							specular:    new THREE.Color('#343434'),				
						})
					);
				}
				sphere.rotation.y = rotation; 
				scene.add(sphere);
				
				var clouds = createClouds(radius, segments);
				function createClouds(radius, segments) {
					return new THREE.Mesh(
						new THREE.SphereGeometry(radius + 0.003, segments, segments),			
						new THREE.MeshPhongMaterial({
							map:         textureLoader.load("js/clouds.png" ),
							transparent: true
						})
					);		
				}
				clouds.rotation.y = rotation;
				scene.add(clouds);
				// СОЗДАНИЕ ЗЕМЛИ ОКОНЧЕНО -------------------------------------------------------------
				
				
				// ДОБАВЛЯЕМ УПРАВЛЕНИЕ КАМЕРОЙ
				controls = new THREE.OrbitControls( camera );
				controls.autoRotate = true;
				controls.autoRotateSpeed = 1;
				
				
				// ДОБАВЛЯЕМ БЛИКИ
				
				var textureFlare0 = textureLoader.load(	"js/lensflare0.png" );
				var textureFlare2 = textureLoader.load( "js/lensflare2.png" );
				var textureFlare3 = textureLoader.load( "js/lensflare3.png" );
				addFlare(0, 0, -5000);
				function addFlare(x, y, z) {
					var flareColor = new THREE.Color( 0xffffff );
					flareColor.setHSL( 0.618, 0.45, 1.0 );
					var lensFlare = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending );
					lensFlare.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending );
					lensFlare.customUpdateCallback = lensFlareUpdateCallback;
					lensFlare.position.set( x, y, z );
				}
				function lensFlareUpdateCallback( object ) {
					var f, fl = object.lensFlares.length;
					var flare;
					var vecX = -object.positionScreen.x * 2;
					var vecY = -object.positionScreen.y * 2;
					for( f = 0; f < fl; f++ ) {
						flare = object.lensFlares[ f ];
						flare.x = object.positionScreen.x + vecX * flare.distance;
						flare.y = object.positionScreen.y + vecY * flare.distance;
						flare.rotation = 0;
					}
					object.lensFlares[ 2 ].y += 0.025;
					object.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + THREE.Math.degToRad( 45 );
				}
				
				
				var rotY = 0.0003;
				var rotY2 = 0.0005;
				
				render();
				
				// РЕНДРИМ
				function render() {
					requestAnimationFrame(render);
					controls.update();
					// stats.update();
					sphere.rotation.y += rotY;
					clouds.rotation.y += rotY2;
					// clouds.rotation.z += 0.0005;	
					render3D.render(scene, camera);
				}
			}
		</script>

	</body>
</html>		
