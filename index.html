<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - adaptive tone-mapping</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#000;
				color:#fff;
				padding:0;
				margin:0;
				overflow:hidden;
				font-family:georgia;
				text-align:center;
			}
			h1 { }
			a { color:skyblue; text-decoration:none }
			canvas { pointer-events:none; z-index:0; position:relative; }
			.label { background-color: black; position: absolute; z-index: 100; padding: 5px }

		</style>
	</head>

	<body>


		<script src="js/three.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<script src="js/CopyShader.js"></script>
		<script src="js/LuminosityShader.js"></script>
		<script src="js/ConvolutionShader.js"></script>
		<script src="js/ToneMapShader.js"></script>
		<script src="js/GammaCorrectionShader.js"></script>

		<script src="js/EffectComposer.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/MaskPass.js"></script>
		<script src="js/ShaderPass.js"></script>
		<script src="js/BloomPass.js"></script>
		<script src="js/AdaptiveToneMappingPass.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/FlyControls.js"></script>
		<script src="js/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, scene, renderer;
			
			var cameraB, sceneB, rendererB;
			var dirLightB;
			var orbitControlsB;
			
			
			// to new
			var bloomPass;
			var hdrEffectComposer;
			var cameraCube, sceneCube;
			var directionalLight;

			var textureLoader;
			var textureFlare0;
			var textureFlare2;
			var textureFlare3;
			var dirLight;
			var count = 0;
			
			var orbitControls;
			
			// to new
			var params = {
				bloomAmount: 1.0,
				sunLight: 4.0,
				enabled: true,
				avgLuminance: 0.7,
				middleGrey: 0.04,
				maxLuminance: 16,
				adaptionRate: 2.0,
			};

			init(); 
			

			function init() {
				


				container = document.createElement( 'div' );
				document.body.appendChild( container );
				// camera
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100000 );
				camera.position.z = 250;
				
				//-----------------------------
				cameraB = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 100000 );
				cameraB.position.z = 250;
				orbitControlsB = new THREE.OrbitControls( cameraB, container );
				orbitControlsB.autoRotate = true;
				orbitControlsB.autoRotateSpeed = 1;
				
				// to new
				cameraCube = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 100000 );
				orbitControls = new THREE.OrbitControls( camera, container );
				orbitControls.autoRotate = true;
				orbitControls.autoRotateSpeed = 1;
				
				
				
				// scene
				scene = new THREE.Scene();
				
				//-------------------------------
				sceneB = new THREE.Scene();
				
				// to new
				sceneCube = new THREE.Scene();
				
				
				// lights
				dirLight = new THREE.DirectionalLight( 0xffffff, params.sunLight );
				dirLight.position.set( 2, 0, -1000 ).normalize();
				scene.add( dirLight );
				dirLight.color.setHSL( 0.618, 0.45, 1.0 );
				
				//-------------------------------------
				dirLightB = new THREE.DirectionalLight( 0xffffff, params.sunLight );
				dirLightB.position.set( 2, 0, -1000 ).normalize();
				sceneB.add( dirLightB );
				dirLightB.color.setHSL( 0.618, 0.45, 1.0 );
				
				//directionalLight = new THREE.DirectionalLight( 0xffffff, params.sunLight );				
				//directionalLight.position.set( 2, 0, 10 ).normalize();
				//scene.add( directionalLight );
				
				// lens flares
				
				textureLoader = new THREE.TextureLoader();
				var tex0 = textureLoader.load( "js/lensflare0.png", function ( tex ) {
					count++;
					textureFlare0 = tex;
					if (count==3) go_to();
				} );
				var tex2 = textureLoader.load( "js/lensflare2.png", function ( tex ) {
					count++;
					textureFlare2 = tex;
					if (count==3) go_to();
				} );
				var tex3 = textureLoader.load( "js/lensflare3.png", function ( tex ) {
					count++;
					textureFlare3 = tex;
					if (count==3) go_to();
				} );
			}
				
			function go_to() {
				console.log(count);
				var flareColor = new THREE.Color( 0xffffff );
				flareColor.setHSL( 0.618, 0.45, 1.0 );
				var lensFlare = new THREE.LensFlare( textureFlare0, 700, 0.0, THREE.AdditiveBlending, flareColor );
				lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
				lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
				lensFlare.add( textureFlare2, 512, 0.0, THREE.AdditiveBlending );
				lensFlare.add( textureFlare3, 60, 0.6, THREE.AdditiveBlending );
				lensFlare.add( textureFlare3, 70, 0.7, THREE.AdditiveBlending );
				lensFlare.add( textureFlare3, 120, 0.9, THREE.AdditiveBlending );
				lensFlare.add( textureFlare3, 70, 1.0, THREE.AdditiveBlending );
				lensFlare.customUpdateCallback = lensFlareUpdateCallback;
				lensFlare.position.set( 2, 0, -1000 );
				sceneB.add( lensFlare );
				
				
				
				// to new							
				var atmoShader = {
					side: THREE.BackSide,
					// blending: THREE.AdditiveBlending,
					transparent: true,
					lights: true,
					uniforms: THREE.UniformsUtils.merge( [
						THREE.UniformsLib[ "common" ],
						THREE.UniformsLib[ "lights" ]
					] ),
					vertexShader: [
						"varying vec3 vViewPosition;",
						"varying vec3 vNormal;",
						"void main() {",
							THREE.ShaderChunk[ "beginnormal_vertex" ],
							THREE.ShaderChunk[ "defaultnormal_vertex" ],
							"	vNormal = normalize( transformedNormal );",
							"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
							"vViewPosition = -mvPosition.xyz;",
							"gl_Position = projectionMatrix * mvPosition;",
						"}"
					].join("\n"),
					fragmentShader: [
						THREE.ShaderChunk[ "common" ],
						THREE.ShaderChunk[ "bsdfs" ],
						THREE.ShaderChunk[ "lights_pars" ],
						THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
						"void main() {",
							"vec3 normal = normalize( -vNormal );",
							"vec3 viewPosition = normalize( vViewPosition );",
							"#if NUM_DIR_LIGHTS > 0",
								"vec3 dirDiffuse = vec3( 0.0 );",
								"for( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {",
									"vec4 lDirection = viewMatrix * vec4( directionalLights[i].direction, 0.0 );",
									"vec3 dirVector = normalize( lDirection.xyz );",
									"float dotProduct = dot( viewPosition, dirVector );",
									"dotProduct = 1.0 * max( dotProduct, 0.0 ) + (1.0 - max( -dot( normal, dirVector ), 0.0 ));",
									"dotProduct *= dotProduct;",
									"dirDiffuse += max( 0.5 * dotProduct, 0.0 ) * directionalLights[i].color;",
								"}",
							"#endif",
							//Fade out atmosphere at edge
							"float viewDot = abs(dot( normal, viewPosition ));",
							"viewDot = clamp( pow( viewDot + 0.6, 10.0 ), 0.0, 1.0);",
							"vec3 colour = vec3( 0.05, 0.09, 0.13 ) * dirDiffuse;",
							"gl_FragColor = vec4( colour, viewDot );",
						"}"
					].join("\n"),
				};
				var earthAtmoMat = new THREE.ShaderMaterial( atmoShader );
				var earthMat = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					shininess: 200
				} );
				var earthDiffuse = textureLoader.load( 'js/earth_atmos_4096.jpg', function( tex ) {
					earthMat.map = tex;
					earthMat.needsUpdate = true;
				} );
				var earthSpecular = textureLoader.load( 'js/earth_specular_2048.jpg', function( tex ) {
					earthMat.specularMap = tex;
					earthMat.needsUpdate = true;
				} );
				var earthLightsMat = new THREE.MeshBasicMaterial( {
					color: 0xffffff,
					blending: THREE.AdditiveBlending,
					transparent: true,
					depthTest: false
				} );
				var earthLights = textureLoader.load( 'js/earth_lights_2048.png', function( tex ) {
					earthLightsMat.map = tex;
					earthLightsMat.needsUpdate = true;
				} );
				var earthCloudsMat = new THREE.MeshLambertMaterial( {
					color: 0xffffff,
					blending: THREE.NormalBlending,
					transparent: true,
					depthTest: false
				} );
				console.log(-20);
				var earthClouds = textureLoader.load( 'js/earth_clouds_2048.png', function( tex ) {
					earthCloudsMat.map = tex;
					earthCloudsMat.needsUpdate = true;
				} );
				console.log(-21);
				var earthGeo = new THREE.SphereGeometry( 100, 24, 24 );
				var sphereMesh = new THREE.Mesh( earthGeo, earthMat );
				scene.add( sphereMesh );
				var sphereLightsMesh = new THREE.Mesh( earthGeo, earthLightsMat );
				scene.add( sphereLightsMesh );
				var sphereCloudsMesh = new THREE.Mesh( earthGeo, earthCloudsMat );
				scene.add( sphereCloudsMesh );
				var sphereAtmoMesh = new THREE.Mesh( earthGeo, earthAtmoMat );
				sphereAtmoMesh.scale.set( 1.05, 1.05, 1.05 );
				scene.add( sphereAtmoMesh );
				console.log(-22);
				
				
				//------------------------------------------
				var dubleS = new THREE.SphereGeometry( 97, 24, 24 );				
				var dubleM = new THREE.MeshPhongMaterial( {
					color: 0xffffff,
					specular: 0xffffff,
					shininess: 200
				} );
				var dubleMesh = new THREE.Mesh( dubleS, dubleM );
				sceneB.add( dubleMesh );
				
				
				var r = "js/";
				var urls = [ r + "dark-s_px.jpg", r + "dark-s_px.jpg",
							 r + "dark-s_px.jpg", r + "dark-s_px.jpg",
							 r + "dark-s_px.jpg", r + "dark-s_px.jpg" ];
				var textureCube = new THREE.CubeTextureLoader().load( urls );
				textureCube.format = THREE.RGBFormat;
				var skyboxShader = THREE.ShaderLib[ "cube" ];
				skyboxShader.uniforms[ "tCube" ].value = textureCube;
				var skyboxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: skyboxShader.fragmentShader,
					vertexShader: skyboxShader.vertexShader,
					uniforms: skyboxShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				} ),
				mesh = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100 ), skyboxMaterial );
				sceneCube.add( mesh );
				console.log(-23);
				
				// renderer
				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setFaceCulling( THREE.CullFaceNone );
				renderer.autoClear = false;
				renderer.gammaInput = true;
				renderer.gammaOutput = false;
				container.appendChild( renderer.domElement );
				console.log(-26);
				
				
				
				//---------------------------------------
				rendererB = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
				rendererB.setPixelRatio( window.devicePixelRatio );
				rendererB.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( rendererB.domElement );
				rendererB.gammaInput = true;
				rendererB.gammaOutput = true;
				
				
				// to new
				var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: false };
				if ( renderer.extensions.get('OES_texture_half_float_linear') ) {
					parameters.type = THREE.FloatType;
				}
				console.log(-27);
				var hdrRenderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, parameters );
				hdrEffectComposer = new THREE.EffectComposer( renderer, hdrRenderTarget );
				var scenePass = new THREE.RenderPass( scene, camera, undefined, undefined, undefined );
				var skyboxPass = new THREE.RenderPass( sceneCube, cameraCube );
				scenePass.clear = false;
				hdrToneMappingPass = new THREE.AdaptiveToneMappingPass( false, 256 );
				bloomPass = new THREE.BloomPass();
				var gammaCorrectionPass = new THREE.ShaderPass( THREE.GammaCorrectionShader );
				gammaCorrectionPass.renderToScreen = true;
				hdrEffectComposer.addPass( skyboxPass );
				hdrEffectComposer.addPass( scenePass );
				hdrEffectComposer.addPass( hdrToneMappingPass );
				hdrEffectComposer.addPass( bloomPass );
				hdrEffectComposer.addPass( gammaCorrectionPass );
				console.log(-28);
				
				// to new
				var gui = new dat.GUI();
				// dynamicHdrGui.add( params, 'projection', { 'From cam to mesh': 'camera', 'Normal to mesh': 'normal' } );
				var sceneGui = gui.addFolder( 'Scenes' );
				var toneMappingGui = gui.addFolder( 'ToneMapping' );
				var staticToneMappingGui = gui.addFolder( 'StaticOnly' );
				var adaptiveToneMappingGui = gui.addFolder( 'AdaptiveOnly' );
				sceneGui.add( params, 'bloomAmount', 0.0, 10.0 );
				sceneGui.add( params, 'sunLight', 0.1, 12.0 );
				toneMappingGui.add( params, 'enabled' );
				toneMappingGui.add( params, 'middleGrey', 0, 12 );
				toneMappingGui.add( params, 'maxLuminance', 1, 30 );
				staticToneMappingGui.add( params, 'avgLuminance', 0.001, 2.0 );
				adaptiveToneMappingGui.add( params, 'adaptionRate', 0.0, 10.0 );
				gui.open();
				console.log(-29);

				// stats
				stats = new Stats();
				container.appendChild( stats.dom );
				// events
				window.addEventListener( 'resize', onWindowResize, false );
				console.log(-30);
				animate();

			}

			function onWindowResize( event ) {
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				
				// to new
				cameraCube.aspect = window.innerWidth / window.innerHeight;
				cameraCube.updateProjectionMatrix();
				
				//-------------------------
				rendererB.setSize( window.innerWidth, window.innerHeight );
				cameraB.aspect = window.innerWidth / window.innerHeight;
				cameraB.updateProjectionMatrix();
			}
			
			function lensFlareUpdateCallback( object ) {
				var f, fl = object.lensFlares.length;
				var flare;
				var vecX = -object.positionScreen.x * 2;
				var vecY = -object.positionScreen.y * 2;
				for( f = 0; f < fl; f++ ) {
					flare = object.lensFlares[ f ];
					flare.x = object.positionScreen.x + vecX * flare.distance;
					flare.y = object.positionScreen.y + vecY * flare.distance;
					flare.rotation = 0;
				}
				object.lensFlares[ 2 ].y += 0.025;
				object.lensFlares[ 3 ].rotation = object.positionScreen.x * 0.5 + THREE.Math.degToRad( 45 );
			}

			function animate() {

				console.log('///---1');
				requestAnimationFrame( animate );
				console.log('///---2');
				
				// to new
				bloomPass.copyUniforms[ "opacity" ].value = params.bloomAmount;
				hdrToneMappingPass.enabled = params.enabled;
				hdrToneMappingPass.setMaxLuminance( params.maxLuminance );
				hdrToneMappingPass.setMiddleGrey( params.middleGrey );
				hdrToneMappingPass.setAverageLuminance( params.avgLuminance );
				orbitControls.update();
				
				orbitControlsB.update();

				render();
				stats.update();
				console.log('///---14');

			}

			function render() {
				console.log('///---9');
				// to new
				camera.lookAt( scene.position );
				cameraCube.rotation.copy( camera.rotation );
				
				
				//-------------------
				cameraB.lookAt( sceneB.position );
				
				
				
				//renderer.render( scene, camera );
				console.log('///---12');
				
				// to new
				//hdrEffectComposer.render( 0.017 );
				rendererB.render( sceneB, cameraB );
				console.log('///---13');
				

			}

		</script>

	</body>
</html>
